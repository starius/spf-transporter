// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: query.sql

package transporterdb

import (
	"context"
	"database/sql"
)

const createRecord = `-- name: CreateRecord :exec
INSERT INTO transport_records (
    burn_id,
    address,
    amount,
    total_supply,
    burn_time,
    queue_up
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateRecordParams struct {
	BurnID      string
	Address     string
	Amount      int64
	TotalSupply sql.NullInt64
	BurnTime    sql.NullTime
	QueueUp     sql.NullTime
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) error {
	_, err := q.db.ExecContext(ctx, createRecord,
		arg.BurnID,
		arg.Address,
		arg.Amount,
		arg.TotalSupply,
		arg.BurnTime,
		arg.QueueUp,
	)
	return err
}

const insertEmissionSnapshot = `-- name: InsertEmissionSnapshot :exec
INSERT INTO emission_history (
    allowed_supply, update_time, tvl
) VALUES (
    $1, $2, $3
)
`

type InsertEmissionSnapshotParams struct {
	AllowedSupply sql.NullInt64
	UpdateTime    sql.NullTime
	Tvl           sql.NullInt64
}

func (q *Queries) InsertEmissionSnapshot(ctx context.Context, arg InsertEmissionSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, insertEmissionSnapshot, arg.AllowedSupply, arg.UpdateTime, arg.Tvl)
	return err
}

const insertSolanaInfo = `-- name: InsertSolanaInfo :exec
UPDATE transport_records
SET invoice_time = $2,
    solana_tx_time = $3,
    solana_tx_id = $4
WHERE burn_id = $1
`

type InsertSolanaInfoParams struct {
	BurnID       string
	InvoiceTime  sql.NullTime
	SolanaTxTime sql.NullTime
	SolanaTxID   sql.NullString
}

func (q *Queries) InsertSolanaInfo(ctx context.Context, arg InsertSolanaInfoParams) error {
	_, err := q.db.ExecContext(ctx, insertSolanaInfo,
		arg.BurnID,
		arg.InvoiceTime,
		arg.SolanaTxTime,
		arg.SolanaTxID,
	)
	return err
}

const insertWhitelisted = `-- name: InsertWhitelisted :exec
INSERT INTO premined_whitelist (
    address, amount
) VALUES (
    $1, $2
)
`

type InsertWhitelistedParams struct {
	Address string
	Amount  int64
}

func (q *Queries) InsertWhitelisted(ctx context.Context, arg InsertWhitelistedParams) error {
	_, err := q.db.ExecContext(ctx, insertWhitelisted, arg.Address, arg.Amount)
	return err
}

const selectEmissionHistory = `-- name: SelectEmissionHistory :many
SELECT id, allowed_supply, update_time, tvl FROM emission_history ORDER BY allowed_supply
`

func (q *Queries) SelectEmissionHistory(ctx context.Context) ([]EmissionHistory, error) {
	rows, err := q.db.QueryContext(ctx, selectEmissionHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmissionHistory
	for rows.Next() {
		var i EmissionHistory
		if err := rows.Scan(
			&i.ID,
			&i.AllowedSupply,
			&i.UpdateTime,
			&i.Tvl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLatestEmissionSnapshot = `-- name: SelectLatestEmissionSnapshot :one
SELECT allowed_supply, update_time, tvl
FROM emission_history
WHERE id = currval(pg_get_serial_sequence('emission_history', 'id'))
`

type SelectLatestEmissionSnapshotRow struct {
	AllowedSupply sql.NullInt64
	UpdateTime    sql.NullTime
	Tvl           sql.NullInt64
}

func (q *Queries) SelectLatestEmissionSnapshot(ctx context.Context) (SelectLatestEmissionSnapshotRow, error) {
	row := q.db.QueryRowContext(ctx, selectLatestEmissionSnapshot)
	var i SelectLatestEmissionSnapshotRow
	err := row.Scan(&i.AllowedSupply, &i.UpdateTime, &i.Tvl)
	return i, err
}

const selectRecord = `-- name: SelectRecord :one
SELECT burn_id, address, amount, total_supply, burn_time, queue_up, invoice_time, solana_tx_time, solana_tx_id, solana_confirmed, completed FROM transport_records
WHERE burn_id = $1
`

func (q *Queries) SelectRecord(ctx context.Context, burnID string) (TransportRecord, error) {
	row := q.db.QueryRowContext(ctx, selectRecord, burnID)
	var i TransportRecord
	err := row.Scan(
		&i.BurnID,
		&i.Address,
		&i.Amount,
		&i.TotalSupply,
		&i.BurnTime,
		&i.QueueUp,
		&i.InvoiceTime,
		&i.SolanaTxTime,
		&i.SolanaTxID,
		&i.SolanaConfirmed,
		&i.Completed,
	)
	return i, err
}

const selectUncompletedRecords = `-- name: SelectUncompletedRecords :many
SELECT
    burn_id,
    address,
    amount,
    total_supply,
    burn_time,
    queue_up
FROM transport_records
WHERE ((completed = FALSE) AND (total_supply > $1) AND (amount + total_supply < $2))
ORDER BY total_supply
`

type SelectUncompletedRecordsParams struct {
	TotalSupply sql.NullInt64
	Amount      int64
}

type SelectUncompletedRecordsRow struct {
	BurnID      string
	Address     string
	Amount      int64
	TotalSupply sql.NullInt64
	BurnTime    sql.NullTime
	QueueUp     sql.NullTime
}

func (q *Queries) SelectUncompletedRecords(ctx context.Context, arg SelectUncompletedRecordsParams) ([]SelectUncompletedRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectUncompletedRecords, arg.TotalSupply, arg.Amount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUncompletedRecordsRow
	for rows.Next() {
		var i SelectUncompletedRecordsRow
		if err := rows.Scan(
			&i.BurnID,
			&i.Address,
			&i.Amount,
			&i.TotalSupply,
			&i.BurnTime,
			&i.QueueUp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectWhitelisted = `-- name: SelectWhitelisted :many
SELECT address, amount FROM premined_whitelist
`

type SelectWhitelistedRow struct {
	Address string
	Amount  int64
}

func (q *Queries) SelectWhitelisted(ctx context.Context) ([]SelectWhitelistedRow, error) {
	rows, err := q.db.QueryContext(ctx, selectWhitelisted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectWhitelistedRow
	for rows.Next() {
		var i SelectWhitelistedRow
		if err := rows.Scan(&i.Address, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCompleted = `-- name: SetCompleted :exec
UPDATE transport_records
SET completed = $2
WHERE burn_id = $1
`

type SetCompletedParams struct {
	BurnID    string
	Completed bool
}

func (q *Queries) SetCompleted(ctx context.Context, arg SetCompletedParams) error {
	_, err := q.db.ExecContext(ctx, setCompleted, arg.BurnID, arg.Completed)
	return err
}

const setSolanaConfirmed = `-- name: SetSolanaConfirmed :exec
UPDATE transport_records
SET solana_confirmed = $2
WHERE burn_id = $1
`

type SetSolanaConfirmedParams struct {
	BurnID          string
	SolanaConfirmed bool
}

func (q *Queries) SetSolanaConfirmed(ctx context.Context, arg SetSolanaConfirmedParams) error {
	_, err := q.db.ExecContext(ctx, setSolanaConfirmed, arg.BurnID, arg.SolanaConfirmed)
	return err
}
